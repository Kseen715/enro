name: Build and Release

on:
  push:
    branches: [ master ]
  workflow_dispatch:

jobs:
  extract-version-and-tag-check:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      should_release: ${{ steps.tag_check.outputs.should_release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for all tags and branches

      - name: Extract version from Cargo.toml
        id: version
        run: |
          VERSION=$(grep -m 1 "^version =" Cargo.toml | cut -d '"' -f 2)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

      - name: Check if tag exists
        id: tag_check
        run: |
          TAG="v${{ steps.version.outputs.version }}"
          if git tag --list | grep -x "$TAG" > /dev/null; then
            echo "Tag $TAG already exists"
            echo "should_release=false" >> $GITHUB_OUTPUT
          else
            echo "Tag $TAG does not exist"
            echo "should_release=true" >> $GITHUB_OUTPUT
          fi

  build:
    needs: extract-version-and-tag-check
    if: needs.extract-version-and-tag-check.outputs.should_release == 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          # Linux targets
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            platform: linux_x86_64
            cross: false
          - os: ubuntu-latest
            target: i686-unknown-linux-gnu
            platform: linux_x86
            cross: true
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            platform: linux_aarch64
            cross: true
          - os: ubuntu-latest
            target: armv7-unknown-linux-gnueabihf
            platform: linux_armv7
            cross: true
          # Windows targets
          - os: ubuntu-latest
            target: x86_64-pc-windows-gnullvm
            platform: win_x86_64
            cross: true
          - os: ubuntu-latest
            target: i686-pc-windows-gnullvm
            platform: win_x86
            cross: true
          - os: ubuntu-latest
            target: aarch64-pc-windows-gnullvm
            platform: win_aarch64
            cross: true
          # macOS targets (need macOS runners)
          - os: macos-latest
            target: x86_64-apple-darwin
            platform: mac_x86_64
            cross: false
          - os: macos-latest
            target: aarch64-apple-darwin
            platform: mac_aarch64
            cross: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install llvm-mingw (pc-windows-gnullvm)
        if: contains(matrix.target, 'pc-windows-gnullvm')
        run: |
          wget https://github.com/mstorsjo/llvm-mingw/releases/download/20251118/llvm-mingw-20251118-ucrt-ubuntu-22.04-x86_64.tar.xz
          tar -xf llvm-mingw-*.tar.xz
          LLVM_MINGW_DIR=$(ls -d llvm-mingw-*/)
          echo "$LLVM_MINGW_DIR/bin" >> $GITHUB_PATH
          clang --version
          
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
            
      - name: Install cross
        if: contains(matrix.os, 'ubuntu')
        uses: taiki-e/install-action@v2
        with:
            tool: cross

      - name: Configure linker (aarch64-pc-windows-gnullvm)
        if: matrix.target == 'aarch64-pc-windows-gnullvm'
        run: |
            mkdir -p .cargo
            cat > .cargo/config.toml <<EOF
            [target.aarch64-pc-windows-gnullvm]
            linker = "aarch64-w64-mingw32-clang"
            EOF
            
      - name: Build for target
        run: |
          if [ "${{ matrix.cross }}" = "true" ] && [ "${{ contains(matrix.os,   'ubuntu') }}" = "true" ] && [[ "${{ matrix.target }}" !=   *"pc-windows-msvc"* ]]; then
            # Use cross for Linux-based cross-compilation (not for Windows   targets)
            cross build --target ${{ matrix.target }} --release
          else
            # Use regular cargo on native platforms or for Windows     cross-compilation from Linux
            cargo build --target ${{ matrix.target }} --release
          fi

      - name: Create artifacts directory
        run: |
            mkdir -p artifacts
            BINARY_NAME="enro"
            if [[ "${{ matrix.target }}" == *"-pc-windows-"* ]]; then
            BINARY_NAME="enro.exe"
            fi

            # Determine final artifact name with platform
            if [[ "${{ matrix.target }}" == *"-pc-windows-"* ]]; then
            FINAL_NAME="enro-${{ needs.extract-version-and-tag-check.outputs.version }}-${{ matrix.platform }}.exe"
            else
            FINAL_NAME="enro-${{ needs.extract-version-and-tag-check.outputs.version }}-${{ matrix.platform }}"
            fi

            cp "target/${{ matrix.target }}/release/$BINARY_NAME" "artifacts/$FINAL_NAME"

      - name: Create installer packages (Linux)
        if: contains(matrix.target, 'linux')
        run: |
            VERSION="${{ needs.extract-version-and-tag-check.outputs.version }}"
            PLATFORM="${{ matrix.platform }}"
            BINARY="enro-$VERSION-$PLATFORM"

            cd artifacts

            # Determine architecture for packaging
            if [ "${{ matrix.target }}" = "i686-unknown-linux-gnu" ]; then
                PKG_ARCH="i386"
                RPM_ARCH="i686"
                MOCK_CONFIG="epel-8-i386"  # or fedora-40-i386 if available
            elif [ "${{ matrix.target }}" = "x86_64-unknown-linux-gnu" ]; then
                PKG_ARCH="amd64"
                RPM_ARCH="x86_64"
                MOCK_CONFIG="epel-8-x86_64"
            elif [ "${{ matrix.target }}" = "aarch64-unknown-linux-gnu" ]; then
                PKG_ARCH="arm64"
                RPM_ARCH="aarch64"
                MOCK_CONFIG="epel-8-aarch64"
            elif [ "${{ matrix.target }}" = "armv7-unknown-linux-gnueabihf" ]; then
                PKG_ARCH="armhf"
                RPM_ARCH="armv7hl"
                MOCK_CONFIG="epel-8-armhfp"
            fi

            # Create .deb package (unchanged)
            mkdir -p enro-deb/usr/local/bin enro-deb/DEBIAN
            cp "$BINARY" enro-deb/usr/local/bin/enro
            chmod +x enro-deb/usr/local/bin/enro
            cat << EOF > enro-deb/DEBIAN/control
            Package: enro
            Version: $VERSION
            Section: utils
            Priority: optional
            Architecture: $PKG_ARCH
            Maintainer: D.N. Korenev
            Description: A command-line tool for file type detection and entropy analysis
            EOF
            dpkg-deb --build enro-deb
            mv enro-deb.deb "$BINARY.deb"

            # Create tar.gz
            tar -czf "$BINARY.tar.gz" "$BINARY"

            # --- RPM via mock in container ---
            echo "Building RPM for $RPM_ARCH using mock in container..."

            # Prepare source structure for RPM
            SRCDIR="mock-rpm"
            mkdir -p "$SRCDIR/BUILD" "$SRCDIR/BUILDROOT" "$SRCDIR/RPMS" "$SRCDIR/SOURCES" "$SRCDIR/SPECS" "$SRCDIR/SRPMS"
            cp "$BINARY" "$SRCDIR/SOURCES/"

            # Create spec file
            cat > "$SRCDIR/SPECS/enro.spec" << EOF
            Name:           enro
            Version:        $VERSION
            Release:        1%{?dist}
            Summary:        A command-line tool for file type detection and entropy analysis
            License:        BSD
            BuildArch:      $RPM_ARCH
            Source0:        %{name}-%{version}-%{RPM_ARCH}

            %description
            A command-line tool for file type detection and entropy analysis
            %prep

            %build

            %install
            rm -rf \$RPM_BUILD_ROOT
            mkdir -p \$RPM_BUILD_ROOT/usr/local/bin
            cp %{SOURCE0} \$RPM_BUILD_ROOT/usr/local/bin/enro
            chmod +x \$RPM_BUILD_ROOT/usr/local/bin/enro

            %files
            /usr/local/bin/enro

            %changelog
            * $(date "+%a %b %d %Y") D.N. Korenev <https://github.com/Kseen715> - $VERSION-1
            - Initial package
            EOF

            # Use Fedora container with mock preinstalled
            docker run --rm \
                -v "$PWD/$SRCDIR:/builddir" \
                -w /builddir \
                fedora:40 \
                /bin/bash -c "
                    set -e
                    dnf install -y mock rpm-build
                    usermod -a -G mock builder 2>/dev/null || true
                    echo '[build]
            chrootgid = $(id -g)
            chrootuid = $(id -u)' > /etc/mock/site-defaults.cfg

                    # Initialize mock chroot
                    mock -r $MOCK_CONFIG --init

                    # Build RPM from spec and source
                    mock -r $MOCK_CONFIG --buildsrpm --spec SPECS/enro.spec --sources SOURCES/
                    mock -r $MOCK_CONFIG --rpmbuild-opts '--define=dist .el8' --rebuild \$(find /builddir -name '*.src.rpm')
                    
                    # Copy out RPMs
                    cp /var/lib/mock/$MOCK_CONFIG/result/*.rpm /builddir/ 2>/dev/null || true
                "

            # Move resulting RPM
            RPM_FILE=$(find "$SRCDIR" -name "*.rpm" -not -name "*.src.rpm" | head -n1)
            if [ -n "$RPM_FILE" ]; then
                mv "$RPM_FILE" "$BINARY.rpm"
                echo "Successfully built RPM: $BINARY.rpm"
            else
                echo "WARNING: No RPM produced for $RPM_ARCH"
                # Optionally fail or continue
            fi

      - name: Create installer packages (Windows)
        if: contains(matrix.target, 'windows')
        run: |
          $VERSION="${{ needs.extract-version-and-tag-check.outputs.version }}"
          $PLATFORM="${{ matrix.platform }}"
          $BINARY="enro-$VERSION-$PLATFORM"

          Set-Location artifacts

          # Create zip archive
          Compress-Archive -Path "$BINARY.exe" -DestinationPath "$BINARY.zip"

          # Create MSI installer using WiX Toolset
          # For now, we'll just create a zip as a placeholder for Windows installer
          # Full MSI creation would require more complex WiX configuration
        shell: pwsh

      - name: Create installer packages (Darwin)
        if: contains(matrix.target, 'darwin')
        run: |
          VERSION="${{ needs.extract-version-and-tag-check.outputs.version }}"
          PLATFORM="${{ matrix.platform }}"
          BINARY="enro-$VERSION-$PLATFORM"
         
          cd artifacts

          # Create tar.gz
          if [ "${{ matrix.target }}" = "x86_64-apple-darwin" ]; then
            ARCH="x86_64"
          elif [ "${{ matrix.target }}" = "aarch64-apple-darwin" ]; then
            ARCH="aarch64"
          fi

          tar -czf "$BINARY.tar.gz" $BINARY

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}
          path: artifacts/*

  release:
    needs: [extract-version-and-tag-check, build]
    runs-on: ubuntu-latest
    if: needs.extract-version-and-tag-check.outputs.should_release == 'true'
    permissions:
      contents: write  # for creating releases

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for all tags and branches

      - name: Create tag
        run: |
          VERSION=${{ needs.extract-version-and-tag-check.outputs.version }}
          TAG="v$VERSION"
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a "$TAG" -m "Release version $VERSION"
          git push origin "$TAG"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: all_artifacts

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.extract-version-and-tag-check.outputs.version }}
          name: "Release v${{ needs.extract-version-and-tag-check.outputs.version }}"
          draft: false
          prerelease: false
          files: |
            all_artifacts/**/*
          body: |
            ## Release v${{ needs.extract-version-and-tag-check.outputs.version }}

            This release includes builds for multiple platforms:
            - Windows (x86, x64, ARM64)
            - macOS (x64, ARM64)
            - Linux (x86, x64, ARMv7, ARMv8)

            The release includes various installer formats:
            - ZIP archives for Windows and macOS
            - tar.gz archives for all platforms
            - DEB packages for Debian/Ubuntu Linux
            - RPM packages for RedHat/Fedora Linux
